* 本資料はある程度技術的素養がある新人のWebアプリケーションエンジニア向けの講義資料として書かれています。
* 本資料は適宜ホワイトボードや口頭で補足説明を行いながら、解説します。
* 本資料は少し前提としている知識量が多いかもしれません。分からない内容がある場合は、遠慮をせずに質問をしてください。
* 本資料に関して間違いや誤解を招く点を発見した場合、Issueに報告して頂けるとありがたいです。

# プロトコルの基礎知識とセキュリティ上の勘所

Webアプリケーションは大きな見方をすれば、ネットワークを通じて外部と通信する処理が中心となるアプリケーションといえます。  
そのため、様々なプロトコルがアプリケーションに遠からず関係することになります。  
ここではいくつかの主要なプロトコルの概要と、セキュリティ上で起き得る（起き得た）問題について解説します。

* [x] Webとプロトコル
* [x] TCPとUDP
* [x] HTTP
* [x] HTTPS(TLS)

# Webとプロトコル

Webを構成する要素の大きな要素の一つとして、プロトコルがあります。  
ブラウザはUDPでDNSにIPアドレスを問い合わせ、TCPでHTTPのメッセージをやりとりすることで、サーバーにリクエストを行っています。  
普段アプリケーションを書いているなかで強く意識することは無いですが、これらがなければWebは成り立ちません。  
逆に言えばプロトコルに欠陥が見つかれば、大きなリスクとなり得ます。  
また、プロトコルに違反した実装では、うまく動かないばかりか本来プロトコル上でカバーできるハズの攻撃に対処できなくなることもあります。  
プロトコルをよく理解した上で利用することで、セキュリティ上の問題に気づきやすくなるだけでなく、
適切な技術選択をすることに役立ち、効率の良い設計を行うことにもつながります。

# TCPとUDP

コンピュターがネットワークを通じて外部と通信するためのプロトコルについて考えます。  
ソフトウェア上からは主にOSI基本参照モデルの第4層（トランスポート層）以上が関係します。  
※ネットワーク層をプログラマブルにするOpen Flowという技術もありますが今回は割愛します。

## TCPの特徴

TCPは確実にデータを届けるためのプロトコルです。
以下のような特徴があります。

* セッションを確立してから実際の通信が始まる
  * セッションの確立にコストが掛かる
  * 3way hand shakingと呼ばれる方法でセッションを確立する(SYN/ACK+SYN/ACK)
  * 存在しない相手/不正な相手とは通信が行えない
* フロー制御/再送制御/輻輳制御が行われる
  * パケットが正しい順番で届くことを保障する
  * 一部のパケットが通信の過程でロスした場合、再送させる
  * パケットを受信したら、どこまで受信したかを示すパケットを返す
  * ネットワークリソースの状態に応じて送信するデータ量を制御する

これらの特徴を利用した攻撃として、たとえば以下のようなものが考えられるでしょう。

* SYNを大量に送信し、SYN+ACKを送信させセッションの確立を待機させる
  * セッションの確立を待機するためのリソースを意図的に消費させることができる→正規のセッションの確立を妨害できる
  * 正規のセッションの確立を妨害することで、アプリケーションへのアクセスを妨害することが可能
  * SYN flooding攻撃と呼ばれている
  * SYN cookiesと呼ばれる方法により対策が可能（ほとんどのLinuxディストリビューションではデフォルトでONとなっている）
    * 似た攻撃手法としてARP floodingやMAC floodingと呼ばれるものもある

このように様々な制御を行うぶん複雑となり、その挙動を悪用した攻撃手法が存在します。
その代わり、下で解説するようなUDP通信の特徴を悪用して行えるような攻撃のほとんどはTCP通信に対しては行うことはできません。

### 演習

netcatを用いて、簡易的なサーバーを作ります。  
以下のコマンドでTCPで5000番ポートでリクエスト待ち受け、受け取った行数をリアルタイムで表示します。
セッションが切断されたらENDと表示されます。

```bash
perl -E '$|=1;say $i++ and sleep 1 while 1' | nc -l -p 5000 | perl -ne 'BEGIN{$|=1};print"\r$."}{print"\nEND\n"'
```

netcatを用いて、TCPでリクエストを送ります。隣の人のサーバーに送信して、お互いに結果を見てみましょう。

```bash
seq 1 1000000 | nc $IP 5000
```

サーバー側は以下のようになるはずです。

```
1000000
END
```

クライアント側は数字のがいくつか表示され、終了するでしょう。
これで順序はともかく、すべてのデータが正しく受信出来たことがなんとなく分かります。
また、お互いに同時にデータを送受信できていることがわかったと思います。
思いつく限りいろいろ試してみましょう。

### 課題(目安:15分)

* TCPの通信において、IPアドレスを偽装して通信を行うことは可能か。また、その根拠を説明せよ。

## UDPの特徴

UDPはシンプルにデータを届けるためのプロトコルです。
以下のような特徴があります。

* セッションを確立する必要が無い
  * 低コストで通信が行える
  * 存在しない相手/不正な相手からデータを受け取る可能性がある
* フロー制御/再送制御/輻輳制御が行われない
  * 一部のパケットが通信の過程でロスした場合、再送されないなど、確実にデータが届く保障は無い
  * ただし、現実的にだいたいのデータが届く

これらの特徴を利用した攻撃として、たとえば以下のようなものが考えられるでしょう。

* DNSのキャッシュからの副問い合わせ(再起問い合わせ)に対して不正なIPアドレスを示すUDPパケットを送り副問い合わせのレスポンスとして認識させる
  * 任意のドメインを任意のIPアドレスに結びつける事が可能
  * DNSキャッシュポイズニングと呼ばれている
    * 以前は、現実的に攻撃が困難だろうと思われていたが、2008年にKaminsky Attackと呼ばれる手法が発見され、攻撃が比較的容易になった
  * Source port randomizationにより対策が可能（多くのDNSサーバーにこの機能がある）
  * 副問い合わせの挙動を制限するオプションが利用出来る場合もあるので設定するとなお良い
  * DNSSECというDNS問い合わせを暗号化する仕様も存在するが普及が進んでいない

このようにシンプルなプロトコルとなっているぶん、信頼性はTCPと比べると低いです。
UDPを使った通信に信頼性が必要なケースには注意が必要です。(基本的にはTCPを用いるのが良いでしょう。)
そのぶん、TCPと比較するとセッションの確立が不要であり、ACKの送信も不要なので、ネットワークコストは下がります。
たとえば、動画や音声のストリーミングにはよくUDPが用いられます。

### 演習

netcatを用いて、簡易的なサーバーを作ります。  
以下のコマンドでUDPで5000番ポートを待ち受け、受け取った行数をリアルタイムで表示します。

```bash
nc -l -u -p 5000 | perl -ne 'BEGIN{$|=1};print"\r$."}{print"\nEND\n"'
```

netcatを用いて、UDPでリクエストを送ります。隣の人のサーバーに送信して、お互いに結果を見てみましょう。

```bash
seq 1 1000000 | nc -u $IP 5000
```

TCPの場合と違い、いくつかのデータが欠損します。
また、セッションの管理を行っていないため、接続/切断という概念がありません。
ただし、送信元のIPアドレス/ポート毎にファイルディスクリプタを生成しているため、
単純に複数のホストから送ってもデータを読ませることはできません。

* `-p 9999`などと送信元のポートを固定して送信してみるとどうなるでしょうか？

### 課題(目安:15分)

* UDPの通信において、IPアドレスを偽装して通信を行うことは可能か。また、その根拠を説明せよ。
* UDP上でTCP相当の信頼性を担保することは可能か。また、その根拠を説明せよ。

## 勘所

* アプリケーションから遠いところにも脆弱性のタネはある
  * TCP/IPの上に独自のプロトコルを定義する必要が出た場合、これらの特徴についてよく理解した上でプロトコルを選び、プロトコルを定義する必要がある
  * アプリケーションエンジニアがサーバーの運用なども行う場合、これら低レイヤのプロトコルについても注意する必要がある
* 現状の対策では防げないほどコンピューターの性能が進化したり、新たな攻撃手法が発見される場合がある
  * あらゆる対策はいつの日か破られる日が来る可能性を秘めている
  * 常に最新の情報を仕入れる必要がある
  * とはいえ、低いレイヤのものほど使い古され、枯れているので、新しく脆弱性が発見される確度は低い
* あらゆる仕様は見方を変えることで攻撃に利用できてしまう場合がある
  * 完璧なモノは存在しない

## 参考資料

* [OSI基本参照モデル](http://www.mm-labo.com/computer/tcpip/basic/OSI.html)
* [3分間ネットワーキング](http://www5e.biglobe.ne.jp/%257eaji/3min/)
* [IPA TCP/IPに係る既知の脆弱性に関する調査報告書](https://www.ipa.go.jp/security/vuln/vuln_TCPIP.html)
* [IPA DNSキャッシュポイズニング対策](https://www.ipa.go.jp/security/vuln/DNS_security.html)
* [Kaminsky Attackの全て](https://www.nic.ad.jp/ja/materials/iw/2008/proceedings/H3/IW2008-H3-07.pdf)
* [マスタリング TCP/IP](http://www.amazon.co.jp/dp/4274068765/)

# HTTP

つい最近、最新版のHTTP/2.0が仕様として承認されました。現在、RFC化が進んでおり、実装は既にいくつか存在します。  
今回はHTTP/2.0には触れませんが、仕様をざっと眺めて攻撃できそうなポイントやその攻撃方法の対策について考察してみても面白いと思います。  
今回はHTTP/1.0のみ、Chunked Transferには触れずに解説します。

先に説明した通り、WebはHTTPのメッセージをやりとりすることで行われます。  
HTTP/1.0はテキストベースのプロトコルです。また、仕様として改行をCRLF(`\r\n`)で表します。  
HTTPのメッセージに以下のような内容をテキストで盛り込んで送信します。

* リクエスト
  * リソースに対するアクション(request method)
  * リソースの名前(request uri)
  * プロトコルのバージョン(HTTP/1.1など)
  * リクエスト自体のメタ情報
  * サーバーに送信する本文
* レスポンス
  * 要求された操作に対するレスポンスの状態(status)
  * レスポンス自体のメタ情報
  * クライアントに送信する本文

HTTPのメッセージは大きく分けてHeaderとBodyに分けられます。  

### リクエスト

`http://localhost/`を要求するリクエストは以下のようになります。

```http
GET / HTTP/1.0
Host: localhost

```

1行目が、「リソースに対するアクション(request method)」、「リソースの名前(request uri)」、「プロトコルのバージョン(HTTP/1.1など)」です。
2行目以降が「リクエスト自体のメタ情報」です。一般にリクエストヘッダと呼ばれる情報はここに記述されます。ここまでがHeaderです。
空行をあけ、その後に「サーバーに送信する本文」が記述されます。Bodyがこれです。
Bodyを送信する場合、以下のようになります。

```http
POST / HTTP/1.0
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 35

name=karupanerura&password=password
```

よく利用されるリクエストヘッダには以下のようなものがあります。

| 名前            | 意味                       | 例                                |
| --------------- | -------------------------- | --------------------------------- |
| Host            | バーチャルホスト           | www.google.co.jp                  |
| Connection      | 接続を保持したいか否か     | close                             |
| Content-Type    | bodyを表現するデータ形式   | application/x-www-form-urlencoded |
| Content-Length  | bodyの長さ                 | 0                                 |
| User-Agent      | クライアントの名前など     | Mozilla/5.0 (Macintosh; ...       |
| Accept          | 受け入れ可能なデータ形式   | text/html,application/xhtml+xml   |
| Accept-Encoding | 受け入れ可能なデータ表現   | gzip,deflate                      |
| Accept-Language | 受け入れ可能な言語         | ja,en-US;q=0.8,en;q=0.6           |
| Cookie          | 送信先に関連するクッキー   | session-id=1234567                |

### レスポンス

レスポンスは以下のように表現します。

```http
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 5

hello
```

よく利用されるレスポンスヘッダには以下のようなものがあります。

| 名前            | 意味                       | 例                                |
| --------------- | -------------------------- | --------------------------------- |
| Server          | サーバーの名前             | nginx                             |
| Connection      | 接続を保持するか否か       | close                             |
| Content-Type    | bodyを表現するデータ形式   | text/html                         |
| Content-Length  | bodyの長さ                 | 123                               |
| Date            | サーバーの現在の日時       | Wed, 15 Apr 2015 14:31:30 GMT     |
| Last-Modified   | コンテンツの最終更新日時   | Sun, 02 Nov 2014 06:47:21 GMT     |
| Set-Cookie      | 保存させたいクッキー       | session_id=1234567                |

## 演習

以下のように簡易的なHTTPサーバーを立ち上げてみましょう。

```bash
echo "HTTP/1.0 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 5\r\n\r\nhello" | nc -l -p 8080
```

これは以下の内容をレスポンスとして返して終了するサーバーです。

```http
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 5

hello
```

ブラウザから`http://$IP:8080/`にアクセスしてみましょう。リクエストとして、以下のような内容が得られるはずです。

```
GET / HTTP/1.1
Host: $IP:8080
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2366.0 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: ja,en-US;q=0.8,en;q=0.6

```

また、実際のHTTPレスポンスも見てみましょう。

```bash
echo "GET / HTTP/1.1\r\nHost: karupas.org\r\nConnection: close\r\n\r\n" | nc karupas.org 80
```

これは以下の内容をリクエストとして送信するクライアントです。

```http
GET / HTTP/1.1
Host: karupas.org
Connection: close

```

レスポンスとして、以下のような内容が得られるはずです。

```http
HTTP/1.1 200 OK
Server: nginx
Date: Wed, 15 Apr 2015 14:31:30 GMT
Content-Type: text/html
Content-Length: 7525
Last-Modified: Sun, 02 Nov 2014 06:47:21 GMT
Connection: close
Vary: Accept-Encoding
ETag: "5455d379-1d65"
Accept-Ranges: bytes

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
..............................
............(省略)............
..............................
```

## 課題(15分)

* HTTPのプロトコル上の特徴を利用してWebサイトになにかしらの損害を与える方法を少なくとも1つ挙げよ。
  * 実装上の不備があると仮定しても良いがHTTP/1.0の仕様は満たしているものとする。
* 通信は暗号化されず平文で行われるが、身近なアプリケーションあるいはWebサイトにおいて、平文で通信されることによって起き得る被害を少なくとも2つ挙げよ。

## 勘所

* 平文で行われる通信はネットワーク上で他のマシンに見えてしまう可能性がある。
* フォーマットが決まっているので、それを悪意のある入力によって崩されないよう注意して実装する必要がある。

## 参考資料

* [Studying HTTP](http://www.eonet.ne.jp/~h-hash/)
* [HTTPの教科書](http://www.amazon.co.jp/dp/B00EESW7K0/)
* [今夜つける HTTPレスポンスヘッダー (セキュリティ編)](http://d.hatena.ne.jp/sen-u/20131130/p1)

# HTTPS(TLS)

HTTPは単体では暗号化されません。よって、経路上で通信内容が第三者に見られてしまう可能性があります。
もっとも、第三者が狙って経路上のネットワークに入り、関連するパケットをすべて収集することは容易ではなく、幾多もの情報のうちのひとつでしかないです。
しかし、近年はFree Wi-Fiとして提供されているオープンなネットワークが増えてきており、
そのようなネットワークにおいて単純なパケットキャプチャにより他のサービスの平文の通信内容を傍受されるリスクが指摘されています。([「Firesheep」:複雑だったことを容易にするツール](http://blog.f-secure.jp/archives/50457114.html))
ユーザーがいつどのようなネットワーク環境でWebサービスを利用するかはわかりませんので、サービスの提供者としては考慮するべき事項です。
幸いなことにHTTPプロトコルをTLSにより暗号化した上で提供するためのスキームが存在します。それがHTTPSです。

## TLS

TLSは以下のことを保障します。

* 正しい相手と通信していること
* 通信内容の改ざんを検知出来ること
* データが暗号化されること

これらを保障するために、共通鍵/公開鍵暗号、ディジタル署名、暗号学的ハッシュ関数などの暗号技術が利用されています。
[詳細](crypto.md)は割愛しますが、フローについてはなんとなく知っておいたほうが良いでしょう。

TLSはおおまかに以下のようなフローでセッションの確立を行います。

1. (ルートサーバーの証明書を持っている)
1. 利用するアルゴリズムのネゴシエーション
1. サーバーの証明書の取得
1. サーバーの証明書の正当性の検証
  1. 証明書の署名が正当であること
  1. 証明書が有効なサーバー(common name)が接続先のサービスと同一であること
  1. 証明書が有効期限内であること -> 証明局への有効期限の問い合わせ（OSCP）
1. 暗号学的擬似乱数による共通鍵の生成/共有
  * RSAやDH法などが利用される

セッションが確立されたら、以下のようにデータを送信します。

1. シーケンス番号を生成する
1. セッションの共通鍵で暗号化を行う
1. 暗号化したデータをMACにより署名する
1. これらを送信する

受信側はシーケンス番号とMACを検証し、改ざんがないことを確認します。

## 勘所

* TODO

## 参考文献

* [RFC5246](http://tools.ietf.org/html/rfc5246)
* [Transport Layer Security - Wikipedia](http://ja.wikipedia.org/wiki/Transport_Layer_Security)
* [http://www.atmarkit.co.jp/ait/articles/1309/05/news042_2.html](http://www.atmarkit.co.jp/ait/articles/1309/05/news042_2.html)
* [SSL/TLSライブラリの正しい使い方(もしくは、コモンネームの検証について)](http://blog.kazuhooku.com/2014/01/ssltls.html)
* [Heartbleed脆弱性と、その背後にあるWebアプリケーションアーキテクチャの一般的欠陥について](http://blog.kazuhooku.com/2014/04/heartbleedweb.html)
* [自社サーバと交信するスマホアプリにおけるサーバ証明書の発行手法について(SSL Pinningと独自CA再考)](http://blog.kazuhooku.com/2014/07/ssl-pinningca.html)
